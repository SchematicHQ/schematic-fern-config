---
title: Element Library

slug: components/advanced-usage
---

The Schematic Components library provides several advanced features for customizing and extending the default behavior.

## Launch Checkout Programmatically

A common billing use case is to present a user with a paywall, and then open a checkout flow to quickly allow them to upgrade their plan. 

Imagine a user is trying to create their 6th AI-generated image, but their current plan only includes 5 images per month. You can present them a paywall explaining they are at their limit and providing a "Upgrade to the Pro Plan" button. When they click the upgrade button, you want to create a seamless upgrade experience by:

1. Opening the checkout flow
2. Pre-selecting the Pro plan they need to upgrade to
3. Taking them directly to the payment step

Here's a barebones implementation of this:

```CustonCheckout.tsx
import {
  CheckoutDialog,
  EmbedProvider,
  useEmbed,
} from "@schematichq/schematic-components";
import { useCallback, useEffect, useState } from "react";

function Checkout() {
  const { layout, stale, hydrate, setAccessToken, setLayout, setCheckoutState } = useEmbed();

  const checkout = useCallback(async () => {
    const response = await fetch("/api/accessToken");
    const result = await response.json();
    setAccessToken(result.accessToken);
    setCheckoutState({ planId: "plan_abc123" })
    setLayout("checkout");
  }, [setAccessToken, setLayout, setCheckoutState]);

  useEffect(() => {
    if (stale) {
      hydrate();
    }
  }, [stale, hydrate]);

  return (
    <>
      <button onClick={checkout}>Upgrade to Pro</button>
      {layout === "checkout" && <CheckoutDialog />}
    </>
  )
}

export default function CustomCheckout() {
  return (
    <EmbedProvider>
      <Checkout />
    </EmbedProvider>
  );
}
```

The key difference here is that instead of rendering our component by default, we're rendering it in reaction to a user action (clicking the "Upgrade to Pro" button). When this button is clicked:

1. We fetch an access token from our backend
2. Provide it to the component
3. Call `setLayout("checkout")`. `layout` determines which screen the checkout flow is currently on.
4. Because `layout` now has a value, the `CheckoutDialog` component will be rendered.

The accepted values for `layout` are: 

| Layout | Notes |
| --- | --- |
| `plan` | The first page of checkout, where the user can select a plan. This is the default page if none is set. |
| `usage` | The page to set any pay in advance entitlements. This tab only appears if the selected plan has pay in advance entitlements. |
| `addons` | The page to select add-ons. |
| `addonsUsage` | The page to set any pay in advance entitlements from a selected add-on. This tab only appears if an add-on with pay in advance entitlements is selected. |
| `credits` | The page to purchase credit bundles. This page only appears if the selected plan has a credit type associated with it. |
| `checkout` | The final checkout page |

{/* 
Our example app has 2 more complete examples of how to use this, including handling errors and loading states.

- Custom checkout from a button: https://github.com/schematichq/schematic-components/blob/main/examples/custom-checkout/CustomCheckout.tsx
- Custom checkout from a "approaching usage limit" notification: https://github.com/schematichq/schematic-components/blob/main/examples/custom-checkout/ApproachingUsageLimit.tsx */}